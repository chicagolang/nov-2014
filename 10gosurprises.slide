10 Go Surprises
10 Nov 2014

Ken Walters
VP Engineering, Brad's Deals
https://github.com/lostghost/go_talks
ken@lostghost.com
@lostghost

* Let's sleep

.play -edit 10gosurprises/sleep.go /^func main/,/^}/

* #1 - Untyped constants are untyped

.link http://blog.golang.org/constants

	const Delay = 2

- Both the constant number 2 and the named contant "Delay" are untyped.
- Constants hold a default type, so if we infer the type from a constant, the inferred type will be the default type of the constant.

	var Foo = Delay

- Foo will be the default type of Delay

	var Bar float32 = Delay

- Bar will be type float32

* #2 - Iota for Elegant Constants

.link https://blog.splice.com/iota-elegant-constants-golang/

- Iota keyword represents successive untyped integer constants.
- Reset whenever "const" appears.
- Increments on each line in the const block.

* Simple Example:

	const (
		C0 = iota // 0
		C1        // 1
		C2        // 2
		_
		_
		C5        // 5
	)

	const (
		C0, N0 = iota, iota  // 0, 0
		C1, N1               // 1, 1
		C2, N2               // 2, 2
		_
		_
		C5, N5               // 5, 5
	)


* Simple Example:

	type category int

	const (
		CatApparel category = iota // 0
		CatBooks                   // 1
		CatHome                    // 2
		CatElectronics             // 3
	)

* Bitmask example:

	type categories int

	const (
		CatApparel categories = 1 << iota  // 1 << 0, 00000001
		CatBooks                           // 1 << 1, 00000010
		CatHome                            // 1 << 2, 00000100
		CatElectronics                     // 1 << 3, 00001000
	)

	fmt.Println(CatBooks | CatElectronics)

	// result: 00001010, 10 in decimal

* #3 - Type assertion to new interface with check

Assume that we are using a io.writer. We may have runtime configuration to change to the specific writer (http response, file, stdout, gzip compressor, csv, etc.)

All of these satisfy the io.Writer interface, but some are buffered, and at times it may be important to ensure content is flushed.

The difference, in most cases, between a buffered writter and an unbuffered writer is the presence of a Flush method, but if we are coding to our standard io.Writer interface, then we can't call Flush.

* Unbuffered Writer

.play -edit 10gosurprises/writer.go /Start/,/End/

* Buffered Writer

.play -edit 10gosurprises/bufferedwriter.go /Start/,/End/

* Flush Our Buffered Writer

.play -edit 10gosurprises/flushwriter.go /Start/,/End/

* Flush Our Buffered Writer

.play -edit 10gosurprises/flushwritercheck.go /Start/,/End/

* Errors

	f, err := os.Open(name)
	if err != nil {
		return err
	}
	codeUsing(f)

Creating Errors

	myError := fmt.Errorf("Something blew up")

	yourError := errors.New("Something else blew up")

* #4 - error is a builtin interface

	type error interface {
		Error() string
	}

- Packages implement their own error types.
- We can create custom error types with richer detail.
- We can use type assertion to check for error types and details.

	foo, err := CustomFunction()
	if customeErr, isCustomError := err.(CustomError); isCustomError {
		if customErr.Code() == 42 {
			// ... Recover gracefully
		}
	}

- *Always*stick*to*the*standard*error*interface*across*package*boundaries.*

* Mock a file system



* Stringer interface for easily printing custom types

- fmt package declares and tests for the Stringer inferface when formatting output.

	type Stringer interface {
		String() string
	}

* Person

.play -edit 10gosurprises/printperson.go /Start/,/End/

* Person

.play -edit 10gosurprises/printprettyperson.go /Start/,/End/

* Custom JSON serializer

Just like the Stringer interface for the fmt package, the json package provides and tests for a Marshaler interface to allow us to create custom JSON serializers.

	// Marshaler is the interface implemented by objects that
	// can marshal themselves into valid JSON.
	type Marshaler interface {
		MarshalJSON() ([]byte, error)
	}

* 

.play -edit 10gosurprises/jsonperson.go /Start/,/End/

* 

.play -edit 10gosurprises/jsonprettyperson.go /Start/,/End/

* Panic and Recover

* More than just tests in tests

* Present
